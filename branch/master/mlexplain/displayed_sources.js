var tracer_files = [

/* --------------------- MLInterpreter.js --------------------- */
  { file: 'MLInterpreter.js', contents: 'var MLInterpreter = (function() {\nwith (MLSyntax) {\nwith (Value) {\nwith (Identifier) {\n\nvar min = function (a, b) {\n  if ((a <= b)) {\n    return (a);\n  } else {\n    return (b);\n  }\n};\n\n\n\n\n\nvar build_initial_env = function (s, ctx) {\n  var func = function (ctx, builtin) {\n    var name = builtin_name(builtin);\n    var value = builtin_value(builtin);\n    var idx = Vector.append(s, Normal(value));\n    return (ExecutionContext.add(name, idx, ctx));\n  };\n  return (MLList.foldl(func, ctx, Value.initial_env));\n};\n\nvar string_of_identifier = function (_fun_arg_) {\n  switch (_fun_arg_.tag) {\n    case "Lident":\n      var id = _fun_arg_.id;\n      return (id);\n    case "Ldot":\n      var path = _fun_arg_.path, id = _fun_arg_.id;\n      return (strappend(strappend(string_of_identifier(path), "."), id));\n  }\n  \n};\n\nvar run_constant = function (_fun_arg_) {\n  switch (_fun_arg_.tag) {\n    case "Constant_integer":\n      var i = _fun_arg_.value;\n      return (Value_int(i));\n    case "Constant_float":\n      var f = _fun_arg_.value;\n      return (Value_float(f));\n    case "Constant_char":\n      var c = _fun_arg_.value;\n      return (Value_char(c));\n    case "Constant_string":\n      var s = _fun_arg_.value;\n      return (Value_string(normalize_string(s)));\n  }\n  \n};\n\nvar run_ident = function (s, ctx, str) {\n  switch (str.tag) {\n    case "Lident":\n      var id = str.id;\n      return (\n        Unsafe.bind(ExecutionContext.find(id, ctx), function (idx) {\n            return (\n              Unsafe.bind(Vector.find(s, idx), function (b) {\n                  return (value_of(s, ctx, b));}));}));\n    case "Ldot":\n      var path = str.path, id = str.id;\n      return (\n        Unsafe.bind(run_ident(s, ctx, path), function (value) {\n            switch (value.tag) {\n              case "Value_struct":\n                var m = value.value;\n                return (\n                  Unsafe.bind(Map.find(id, m), function (idx) {\n                      return (\n                        Unsafe.bind(Vector.find(s, idx), function (b) {\n                            return (value_of(s, ctx, b));}));}));\n              default:\n                return (\n                  Unsafe.error("Try to get attribute from non-module value"));\n            }\n            }));\n  }\n  \n};\n\nvar run_expression = function (s, ctx, _term_) {\n  switch (_term_.tag) {\n    case "Expression_constant":\n      var c = _term_.constant;\n      return (Unsafe.box(run_constant(c)));\n    case "Expression_ident":\n      var id = _term_.id;\n      return (run_ident(s, ctx, id));\n    case "Expression_let":\n      var is_rec = _term_.is_rec, patts = _term_.ids, exp_ary = _term_.exps,\n        e2 = _term_.expr;\n      if (is_rec) {\n        var prealloc = function (p) {\n          switch (p.tag) {\n            case "Pattern_var":\n              var id = p.id;\n              return (Unsafe.box(id));\n            default:\n              return (\n                Unsafe.error(\n                  "Used pattern other than variable in recursive definition"));\n          }\n          \n        };\n        var exps = MLList.of_array(exp_ary);\n        return (\n          Unsafe.bind(MLArray.sequence_unsafe(MLArray.map(prealloc, patts)),\n            function (id_ary) {\n              var ids = MLList.of_array(id_ary);\n              var func = function (ctx, id, exp) {\n                var idx = Vector.append(s, Prealloc(exp, ctx));\n                var ctx$ = ExecutionContext.add(id, idx, ctx);\n                Vector.set(s, idx, Prealloc(exp, ctx$));\n                return (ctx$);\n              };\n              var ctx$ = MLList.foldl2(func, ctx, ids, exps);\n              return (run_expression(s, ctx$, e2));}));\n      } else {\n        var func = function (ctx_nsf, patt, exp) {\n          return (\n            Unsafe.bind(ctx_nsf, function (ctx) {\n                return (\n                  Unsafe.bind(run_expression(s, ctx, exp), function (v) {\n                      return (pattern_match(s, ctx, v, patt));}));}));\n        };\n        var patt_list = MLList.of_array(patts);\n        var exps = MLList.of_array(exp_ary);\n        return (\n          Unsafe.bind(MLList.foldl2(func, Unsafe.box(ctx), patt_list, exps),\n            function (ctx$) { return (run_expression(s, ctx$, e2));}));\n      }\n    case "Expression_function":\n      var cases = _term_.cases;\n      var func = function (value) {\n        return (pattern_match_many(s, ctx, value, MLList.of_array(cases)));\n      };\n      return (Unsafe.box(Value_fun(func)));\n    case "Expression_apply":\n      var fe = _term_.func, argse = _term_.args;\n      var apply_fun = function (func, ctx, arg, args) {\n        return (\n          Unsafe.bind(run_expression(s, ctx, arg), function (v) {\n              return (\n                Unsafe.bind(func(v), function (res) {\n                    return (run_apply(res, args));}));}));\n      };\nvar run_apply = function (func, args) {\n        switch (args.tag) {\n          case "[]":\n            return (Unsafe.box(func));\n          case "::":\n            var x = args.head, xs = args.tail;\n            switch (func.tag) {\n              case "Value_fun":\n                var f = func.value;\n                return (apply_fun(f, ctx, x, xs));\n              default:\n                return (Unsafe.error("Expected a function value"));\n            }\n            \n        }\n        \n      };\n      return (\n        Unsafe.bind(run_expression(s, ctx, fe), function (func) {\n            return (run_apply(func, MLList.of_array(argse)));}));\n    case "Expression_tuple":\n      var tuple = _term_.components;\n      var value_nsfs = MLArray.map(function (e) {\n                           return (run_expression(s, ctx, e));}, tuple);\n      return (\n        Unsafe.bind(MLArray.sequence_unsafe(value_nsfs), function (t) {\n            return (Unsafe.box(Value_tuple(t)));}));\n    case "Expression_array":\n      var ary = _term_.elements;\n      var value_nsfs = MLArray.map(function (e) {\n                           return (run_expression(s, ctx, e));}, ary);\n      return (\n        Unsafe.bind(MLArray.sequence_unsafe(value_nsfs), function (a) {\n            return (Unsafe.box(Value_array(a)));}));\n    case "Expression_variant":\n      var label = _term_.label, expr_opt = _term_.value_opt;\n      var value_nsf = Unsafe.bind(Unsafe.of_option(expr_opt), function (e) {\n                          return (run_expression(s, ctx, e));});\n      var value_opt = Option.bind(expr_opt, function (e) {\n                          return (Some(value_nsf));});\n      var variant = {\n        label: label,\n        value_opt: value_opt\n      };\n      return (Unsafe.box(Value_variant(variant)));\n    case "Expression_match":\n      var loc = _term_.loc, expr = _term_.expr, cases = _term_.cases;\n      var func = Expression_function(loc, cases);\n      var app = Expression_apply(loc, func, [expr]);\n      return (run_expression(s, ctx, app));\n    case "Expression_constructor":\n      var ctor = _term_.ctor, args = _term_.args;\n      var value_nsfs = MLArray.map(function (e) {\n                           return (run_expression(s, ctx, e));}, args);\n      return (\n        Unsafe.bind(MLArray.sequence_unsafe(value_nsfs), function (values) {\n            var sum = Sumtype({\n                          constructor: string_of_identifier(ctor),\n                          args: values});\n            return (Unsafe.box(Value_custom(sum)));}));\n    case "Expression_record":\n      var bindings = _term_.bindings, base_opt = _term_.base;\n      var add_to_map = function (map_nsf, binding) {\n        return (\n          Unsafe.bind(map_nsf, function (map) {\n              return (\n                Unsafe.bind(run_expression(s, ctx, binding.expr),\n                  function (value) {\n                    var idx = Vector.append(s, Normal(value));\n                    return (Unsafe.box(Map.add(binding.name, idx, map)));}));\n            }));\n      };\n      var string_eq = function (s1, s2) {\n        return ((string_compare(s1, s2) === 0));\n      };\n      var empty_map = Map.empty_map(string_eq, function (r) { return (r);});\n      var map_from_value = function (v) {\n        return (\n          do_record_with_default(v, empty_map, function (r) { return (r);}));\n      };\n      var base_map = Unsafe.do_with_default(Unsafe.of_option(base_opt),\n                       empty_map, function (base) {\n                         return (\n                           Unsafe.do_with_default(\n                             run_expression(s, ctx, base), empty_map,\n                             function (v) { return (map_from_value(v));}));});\n      return (\n        Unsafe.bind(MLArray.fold(add_to_map, Unsafe.box(base_map), bindings),\n          function (map) {\n            var r = Record(map);\n            return (Unsafe.box(Value_custom(r)));}));\n    case "Expression_field":\n      var record = _term_.record, fieldname = _term_.fieldname;\n      return (\n        Unsafe.bind(run_expression(s, ctx, record), function (value) {\n            return (\n              do_record(value, function (record) {\n                  return (\n                    Unsafe.bind(Map.find(fieldname, record), function (idx) {\n                        return (\n                          Unsafe.bind(Vector.find(s, idx),\n                            function (binding) {\n                              return (value_of(s, ctx, binding));}));}));}));\n          }));\n    case "Expression_setfield":\n      var record = _term_.record, fieldname = _term_.fieldname,\n        expr = _term_.expr;\n      return (\n        Unsafe.bind(run_expression(s, ctx, record), function (value) {\n            return (\n              do_record(value, function (record) {\n                  return (\n                    Unsafe.bind(Map.find(fieldname, record), function (idx) {\n                        return (\n                          Unsafe.bind(run_expression(s, ctx, expr),\n                            function (v) {\n                              var ignore = Vector.set(s, idx, Normal(v));\n                              return (Unsafe.box(nil));}));}));}));}));\n    case "Expression_ifthenelse":\n      var cond = _term_.cond, e1 = _term_.e1, e2 = _term_.e2;\n      return (\n        Unsafe.bind(run_expression(s, ctx, cond), function (cond_val) {\n            if (is_sumtype_ctor("true", cond_val)) {\n              return (run_expression(s, ctx, e1));\n            } else {\n              return (\n                Unsafe.do_with_default(Unsafe.of_option(e2), Unsafe.box(nil),\n                  function (e) { return (run_expression(s, ctx, e));}));\n            }}));\n    case "Expression_sequence":\n      var e1 = _term_.e1, e2 = _term_.e2;\n      run_expression(s, ctx, e1);\n      return (run_expression(s, ctx, e2));\n    case "Expression_while":\n      var loc = _term_.loc, cond_expr = _term_.cond, body = _term_.body;\n      var while_expr = Expression_while(loc, cond_expr, body);\n      return (\n        Unsafe.bind(run_expression(s, ctx, cond_expr), function (cond) {\n            return (\n              do_sumtype(cond, function (b) {\n                  if ((b.constructor === "true")) {\n                    run_expression(s, ctx, body);\n                    return (run_expression(s, ctx, while_expr));\n                  } else {\n                    return (Unsafe.box(nil));\n                  }}));}));\n    case "Expression_for":\n      var id = _term_.id, fst = _term_.first, lst = _term_.last,\n        dir = _term_.up, body = _term_.body;\n      return (\n        Unsafe.bind(run_expression(s, ctx, fst), function (first) {\n            return (\n              Unsafe.bind(run_expression(s, ctx, lst), function (last) {\n                  var idx = Vector.append(s, Normal(first));\n                  var ctx$ = ExecutionContext.add(id, idx, ctx);\n                  if (dir) {\n                    var step_value = 1;\n                  } else {\n                    var step_value = -1;\n                  }\n                  var step = function (v) {\n                    switch (v.tag) {\n                      case "Value_int":\n                        var i = v.value;\n                        return (Unsafe.box(Value_int((i + step_value))));\n                      default:\n                        return (Unsafe.error("Expected an int"));\n                    }\n                    \n                  };\n                  var get_int = function (v) {\n                    switch (v.tag) {\n                      case "Value_int":\n                        var i = v.value;\n                        return (Unsafe.box(i));\n                      default:\n                        return (Unsafe.error("Expected an int"));\n                    }\n                    \n                  };\n                  var iter = function (nil) {\n                    return (\n                      Unsafe.bind(Vector.find(s, idx), function (b) {\n                          return (\n                            Unsafe.bind(value_of(s, ctx, b), function (v) {\n                                return (\n                                  Unsafe.bind(get_int(v), function (iv) {\n                                      return (\n                                        Unsafe.bind(get_int(last),\n                                          function (ilast) {\n                                            var fv = number_of_int(iv);\n                                            var flast = number_of_int(ilast);\n                                            if (((dir && (fv <= flast))\n                                                || (!(dir) && (fv >= flast)))) {\n                                              return (\n                                                Unsafe.bind(\n                                                  run_expression(s, ctx$,\n                                                    body), function (res) {\n                                                    return (\n                                                      Unsafe.bind(step(v),\n                                                        function (v$) {\n                                                          Vector.set(s, idx,\n                                                            Normal(v$));\n                                                          return (iter({}));\n                                                        }));}));\n                                            } else {\n                                              return (Unsafe.box(Value.nil));\n                                            }}));}));}));}));\n                  };\n                  return (iter({}));}));}));\n    case "Expression_try":\n      var expr = _term_.expr, cases = _term_.cases;\n      var ret = run_expression(s, ctx, expr);\n      switch (ret.tag) {\n        case "Exception":\n          var x = ret.except;\n          return (pattern_match_many(s, ctx, x, MLList.of_array(cases)));\n        default:\n          return (ret);\n      }\n      \n    case "Expression_letmodule":\n      var id = _term_.id, modex = _term_.modex, expr = _term_.expr;\n      return (\n        Unsafe.bind(run_module_expression(s, ctx, modex), function (md) {\n            var ident = string_of_identifier(id);\n            var idx = Vector.append(s, Normal(md));\n            var ctx$ = ExecutionContext.add(ident, idx, ctx);\n            return (run_expression(s, ctx$, expr));}));\n    case "Expression_pack":\n      var expr = _term_.expr;\n      return (run_module_expression(s, ctx, expr));\n    case "Expression_assert":\n      var expr = _term_.expr;\n      return (\n        Unsafe.bind(run_expression(s, ctx, expr), function (res) {\n            return (\n              Unsafe.bind(bool_of_value(res), function (b) {\n                  if (b) {\n                    return (Unsafe.box(nil));\n                  } else {\n                    return (\n                      Unsafe.except(\n                        Value_exception({\n                            constructor: "Assert_failure",\n                            args: []})));\n                  }}));}));\n  }\n  \n};\n\nvar value_of = function (s, ctx, b) {\n  switch (b.tag) {\n    case "Normal":\n      var v = b.normal_alloc;\n      return (Unsafe.box(v));\n    case "Prealloc":\n      var e = b.prealloc, ctx$ = b.ctx;\n      return (run_expression(s, ctx$, e));\n  }\n  \n};\n\nvar pattern_match = function (s, ctx, value, patt) {\n  switch (patt.tag) {\n    case "Pattern_any":\n      return (Unsafe.box(ctx));\n    case "Pattern_var":\n      var id = patt.id;\n      var idx = Vector.append(s, Normal(value));\n      return (Unsafe.box(ExecutionContext.add(id, idx, ctx)));\n    case "Pattern_constant":\n      var c = patt.constant;\n      var v1 = run_constant(c);\n      if (value_eq(v1, value)) {\n        return (Unsafe.box(ctx));\n      } else {\n        return (Unsafe.error("Matching failure"));\n      }\n    case "Pattern_tuple":\n      var patts = patt.patts;\n      switch (value.tag) {\n        case "Value_tuple":\n          var tuples = value.value;\n          return (pattern_match_array(s, ctx, tuples, patts));\n        default:\n          return (Unsafe.error("Expected a tuple"));\n      }\n      \n    case "Pattern_array":\n      var patts = patt.patts;\n      switch (value.tag) {\n        case "Value_array":\n          var ary = value.value;\n          if ((MLArray.length(patts) === MLArray.length(ary))) {\n            return (pattern_match_array(s, ctx, ary, patts));\n          } else {\n            return (Unsafe.error("Array lengths don\'t match"));\n          }\n        default:\n          return (Unsafe.error("Expected an array"));\n      }\n      \n    case "Pattern_variant":\n      var label = patt.label, patt_opt = patt.arg;\n      switch (value.tag) {\n        case "Value_variant":\n          var variant = value.value;\n          if ((variant.label === label)) {\n            switch (patt_opt.tag) {\n              case "None":\n                var _switch_arg_1 = variant.value_opt;\n                switch (_switch_arg_1.tag) {\n                  case "None":\n                    return (Unsafe.box(ctx));\n                  case "Some":\n                    return (\n                      Unsafe.error("Unexpected argument for the variant"));\n                }\n                \n              case "Some":\n                var patt = patt_opt.value;\n                var _switch_arg_2 = variant.value_opt;\n                switch (_switch_arg_2.tag) {\n                  case "None":\n                    return (\n                      Unsafe.error("Expected an argument for the variant"));\n                  case "Some":\n                    var v_nsf = _switch_arg_2.value;\n                    return (\n                      Unsafe.bind(v_nsf, function (v) {\n                          return (pattern_match(s, ctx, v, patt));}));\n                }\n                \n            }\n            \n          } else {\n            return (Unsafe.error("Matching failure"));\n          }\n        default:\n          return (Unsafe.error("Matching failure"));\n      }\n      \n    case "Pattern_alias":\n      var subpatt = patt.patt, alias = patt.alias;\n      return (\n        Unsafe.bind(pattern_match(s, ctx, value, subpatt), function (ctx$) {\n            var idx = Vector.append(s, Normal(value));\n            return (Unsafe.box(ExecutionContext.add(alias, idx, ctx$)));}));\n    case "Pattern_constructor":\n      var ctor = patt.ctor, args = patt.args;\n      return (\n        do_sumtype(value, function (sum) {\n            if ((sum.constructor === string_of_identifier(ctor))) {\n              return (pattern_match_array(s, ctx, sum.args, args));\n            } else {\n              return (Unsafe.error("Matching failure"));\n            }}));\n    case "Pattern_or":\n      var patt1 = patt.patt1, patt2 = patt.patt2;\n      return (\n        Unsafe.do_with_default(pattern_match(s, ctx, value, patt1),\n          pattern_match(s, ctx, value, patt2), function (ctx$) {\n            return (Unsafe.box(ctx$));}));\n  }\n  \n};\n\nvar pattern_match_many = function (s, ctx, value, cases) {\n  switch (cases.tag) {\n    case "[]":\n      return (Unsafe.error("Matching failure"));\n    case "::":\n      var x = cases.head, xs = cases.tail;\n      var _switch_arg_3 = pattern_match(s, ctx, value, x.patt);\n      switch (_switch_arg_3.tag) {\n        case "Error":\n          var e = _switch_arg_3.error;\n          return (pattern_match_many(s, ctx, value, xs));\n        case "Result":\n          var ctx$ = _switch_arg_3.result;\n          var _switch_arg_4 = x.guard;\n          switch (_switch_arg_4.tag) {\n            case "None":\n              return (run_expression(s, ctx$, x.expr));\n            case "Some":\n              var guard = _switch_arg_4.value;\n              return (\n                Unsafe.bind(run_expression(s, ctx$, guard), function (res) {\n                    return (\n                      Unsafe.bind(bool_of_value(res), function (b) {\n                          if (b) {\n                            return (run_expression(s, ctx$, x.expr));\n                          } else {\n                            return (pattern_match_many(s, ctx, value, xs));\n                          }}));}));\n          }\n          \n        case "Exception":\n          var ex = _switch_arg_3.except;\n          return (Unsafe.Exception(ex));\n      }\n      \n  }\n  \n};\n\nvar pattern_match_array = function (s, ctx, ary, patts) {\n  var len = MLArray.length(patts);\n  var vallen = MLArray.length(ary);\n  var flen = number_of_int(len);\n  var fvallen = number_of_int(vallen);\n  var min_len = int_of_number(min(flen, fvallen));\n  var for_loop = function (ctx_nsf, i) {\n    if ((i === min_len)) {\n      return (ctx_nsf);\n    } else {\n      var some_case_func = function (ctx) {\n        var vali = MLArray.get(ary, i);\n        var patti = MLArray.get(patts, i);\n        return (for_loop(pattern_match(s, ctx, vali, patti), (i + 1)));\n      };\n      return (Unsafe.bind(ctx_nsf, some_case_func));\n    }\n  };\n  return (for_loop(Unsafe.box(ctx), 0));\n};\n\nvar run_structure_item = function (s, ctx, _term_) {\n  switch (_term_.tag) {\n    case "Structure_eval":\n      var e = _term_.expr;\n      return (\n        Unsafe.bind(run_expression(s, ctx, e), function (v) {\n            return (Unsafe.box({ value: v,\n                                 ctx: ctx}));}));\n    case "Structure_value":\n      var is_rec = _term_.is_rec, patts = _term_.ids, exp_ary = _term_.exps;\n      if (is_rec) {\n        var prealloc = function (p) {\n          switch (p.tag) {\n            case "Pattern_var":\n              var id = p.id;\n              return (Unsafe.box(id));\n            default:\n              return (\n                Unsafe.error(\n                  "Used a pattern other than variable in recursive definition"));\n          }\n          \n        };\n        var exps = MLList.of_array(exp_ary);\n        var prealloc_vars = MLArray.map(prealloc, patts);\n        return (\n          Unsafe.bind(MLArray.sequence_unsafe(prealloc_vars),\n            function (id_ary) {\n              var ids = MLList.of_array(id_ary);\n              var func = function (ctx, id, exp) {\n                var idx = Vector.append(s, Prealloc(exp, ctx));\n                var ctx$ = ExecutionContext.add(id, idx, ctx);\n                Vector.set(s, idx, Prealloc(exp, ctx$));\n                return (ctx$);\n              };\n              var ctx$ = MLList.foldl2(func, ctx, ids, exps);\n              var id = MLArray.get(id_ary, (MLArray.length(id_ary) - 1));\n              return (\n                Unsafe.bind(ExecutionContext.find(id, ctx$), function (idx) {\n                    return (\n                      Unsafe.bind(Vector.find(s, idx), function (binding) {\n                          return (\n                            Unsafe.bind(value_of(s, ctx$, binding),\n                              function (v) {\n                                return (Unsafe.box({ value: v,\n                                                     ctx: ctx$}));}));}));}));\n            }));\n      } else {\n        var func = function (ctx_nsf, patt, exp) {\n          return (\n            Unsafe.bind(ctx_nsf, function (ctx) {\n                return (\n                  Unsafe.bind(run_expression(s, ctx, exp), function (v) {\n                      return (pattern_match(s, ctx, v, patt));}));}));\n        };\n        var patt_list = MLList.of_array(patts);\n        var exps = MLList.of_array(exp_ary);\n        return (\n          Unsafe.bind(MLList.foldl2(func, Unsafe.box(ctx), patt_list, exps),\n            function (ctx$) {\n              var elems = Map.elems(\n                            ExecutionContext.execution_ctx_lexical_env(ctx$));\n              var rev_elems = MLList.rev(elems);\n              switch (rev_elems.tag) {\n                case "[]":\n                  throw false;\n                  break;\n                case "::":\n                  var h = rev_elems.head, t = rev_elems.tail;\n                  var idx_opt = Unsafe.box(h);\n                  break;\n              }\n              \n              return (\n                Unsafe.bind(idx_opt, function (idx) {\n                    return (\n                      Unsafe.bind(Vector.find(s, idx), function (last) {\n                          return (\n                            Unsafe.bind(value_of(s, ctx$, last),\n                              function (v) {\n                                return (Unsafe.box({ value: v,\n                                                     ctx: ctx$}));}));}));}));\n            }));\n      }\n    case "Structure_type":\n      return (Unsafe.box({ value: nil,\n                           ctx: ctx}));\n    case "Structure_module":\n      var id = _term_.id, expr = _term_.expr;\n      return (\n        Unsafe.bind(run_module_expression(s, ctx, expr), function (m) {\n            var idx = Vector.append(s, Normal(m));\n            var ctx$ = ExecutionContext.add(id, idx, ctx);\n            return (Unsafe.box({ value: m,\n                                 ctx: ctx$}));}));\n    case "Structure_modtype":\n      return (Unsafe.box({ value: nil,\n                           ctx: ctx}));\n    case "Structure_include":\n      var expr = _term_.expr;\n      return (\n        Unsafe.bind(run_module_expression(s, ctx, expr), function (value) {\n            switch (value.tag) {\n              case "Value_struct":\n                var str = value.value;\n                var map = Map.union(str,\n                            ExecutionContext.execution_ctx_lexical_env(ctx));\n                return (\n                  Unsafe.box({ value: nil,\n                               ctx: ExecutionContext.from_map(map)}));\n              default:\n                return (Unsafe.error("Expected a module value"));\n            }\n            }));\n    case "Structure_primitive":\n      return (Unsafe.box({ value: nil,\n                           ctx: ctx}));\n    case "Structure_exception":\n      return (Unsafe.box({ value: nil,\n                           ctx: ctx}));\n    case "Structure_open":\n      var id = _term_.id;\n      return (\n        Unsafe.bind(run_ident(s, ctx, id), function (v) {\n            switch (v.tag) {\n              case "Value_struct":\n                var md = v.value;\n                return (\n                  Unsafe.box({\n                      value: nil,\n                      ctx: ExecutionContext.open_module(id, md, ctx)}));\n              default:\n                return (Unsafe.error("Expected a module"));\n            }\n            }));\n  }\n  \n};\n\nvar run_module_expression = function (s, ctx, _term_) {\n  switch (_term_.tag) {\n    case "Module_ident":\n      var id = _term_.id;\n      return (run_ident(s, ctx, id));\n    case "Module_structure":\n      var str = _term_.structure;\n      return (\n        Unsafe.bind(run_structure(s, ctx, str), function (res) {\n            var map = ExecutionContext.execution_ctx_lexical_env(res.ctx);\n            return (Unsafe.box(Value_struct(map)));}));\n    case "Module_functor":\n      var id = _term_.id, expr = _term_.expr;\n      var func = function (varg) {\n        var idx = Vector.append(s, Normal(varg));\n        var ctx$ = ExecutionContext.add(id, idx, ctx);\n        return (run_module_expression(s, ctx$, expr));\n      };\n      return (Unsafe.box(Value_functor(func)));\n    case "Module_apply":\n      var f = _term_.func, e = _term_.expr;\n      return (\n        Unsafe.bind(run_module_expression(s, ctx, f), function (func) {\n            return (\n              Unsafe.bind(run_module_expression(s, ctx, e), function (expr) {\n                  switch (func.tag) {\n                    case "Value_functor":\n                      var fctor = func.value;\n                      return (fctor(expr));\n                    default:\n                      return (Unsafe.error("Expected a functor"));\n                  }\n                  }));}));\n    case "Module_constraint":\n      var expr = _term_.expr;\n      return (run_module_expression(s, ctx, expr));\n    case "Module_unpack":\n      var expr = _term_.expr;\n      return (run_expression(s, ctx, expr));\n  }\n  \n};\n\nvar run_structure = function (s, ctx, _term_) {\n  var func = function (nsf, _term_) {\n    return (\n      Unsafe.bind(nsf, function (res) {\n          return (run_structure_item(s, res.ctx, _term_));}));\n  };\n  var fake_res = Unsafe.box({ value: nil,\n                              ctx: ctx});\n  switch (_term_.tag) {\n    case "Structure":\n      var items = _term_.items;\n      return (MLArray.fold(func, fake_res, items));\n  }\n  \n};\n\nvar run = function (s, ctx, _term_) {\n  return (\n    Unsafe.bind(run_structure(s, ctx, _term_), function (res) {\n        return (Unsafe.box(res.ctx));}));\n};\n}// end of with MLSyntax\n}// end of with Value\n}// end of with Identifier\n\nreturn {\n  min: min, \n  build_initial_env: build_initial_env, \n  string_of_identifier: string_of_identifier, \n  run_constant: run_constant, \n  run_ident: run_ident, \n  run_expression: run_expression, \n  value_of: value_of, \n  pattern_match: pattern_match, \n  pattern_match_many: pattern_match_many, \n  pattern_match_array: pattern_match_array, \n  run_structure_item: run_structure_item, \n  run_module_expression: run_module_expression, \n  run_structure: run_structure, \n  run: run};\n})();\n'},

/* --------------------- MLInterpreter.pseudo --------------------- */
  { file: 'MLInterpreter.pseudo', contents: 'var MLInterpreter = (function() {\nwith (MLSyntax) {\nwith (Value) {\nwith (Identifier) {\n\nvar min = function (a, b) {\n  if ((a <= b)) {\n    return (a);\n  } else {\n    return (b);\n  }\n};\n\n\n\n\n\nvar build_initial_env = function (s, ctx) {\n  var func = function (ctx, builtin) {\n    var name = builtin_name(builtin);\n    var value = builtin_value(builtin);\n    var idx = Vector.append(s, Normal(value));\n    return (ExecutionContext.add(name, idx, ctx));\n  };\n  return (MLList.foldl(func, ctx, Value.initial_env));\n};\n\nvar string_of_identifier = function (_fun_arg_) {\n  switch (_fun_arg_) {\n    case Lident(id):\n      return (id);\n    case Ldot(path, id):\n      return (strappend(strappend(string_of_identifier(path), "."), id));\n  }\n  \n};\n\nvar run_constant = function (_fun_arg_) {\n  switch (_fun_arg_) {\n    case Constant_integer(i):\n      return (Value_int(i));\n    case Constant_float(f):\n      return (Value_float(f));\n    case Constant_char(c):\n      return (Value_char(c));\n    case Constant_string(s):\n      return (Value_string(normalize_string(s)));\n  }\n  \n};\n\nvar run_ident = function (s, ctx, str) {\n  switch (str) {\n    case Lident(id):\n      return (\n        Unsafe.bind(ExecutionContext.find(id, ctx), function (idx) {\n            return (\n              Unsafe.bind(Vector.find(s, idx), function (b) {\n                  return (value_of(s, ctx, b));}));}));\n    case Ldot(path, id):\n      return (\n        Unsafe.bind(run_ident(s, ctx, path), function (value) {\n            switch (value) {\n              case Value_struct(m):\n                return (\n                  Unsafe.bind(Map.find(id, m), function (idx) {\n                      return (\n                        Unsafe.bind(Vector.find(s, idx), function (b) {\n                            return (value_of(s, ctx, b));}));}));\n              default:\n                return (\n                  Unsafe.error("Try to get attribute from non-module value"));\n            }\n            }));\n  }\n  \n};\n\nvar run_expression = function (s, ctx, _term_) {\n  switch (_term_) {\n    case Expression_constant(c):\n      return (Unsafe.box(run_constant(c)));\n    case Expression_ident(id):\n      return (run_ident(s, ctx, id));\n    case Expression_let(is_rec, patts, exp_ary, e2):\n      if (is_rec) {\n        var prealloc = function (p) {\n          switch (p) {\n            case Pattern_var(id):\n              return (Unsafe.box(id));\n            default:\n              return (\n                Unsafe.error(\n                  "Used pattern other than variable in recursive definition"));\n          }\n          \n        };\n        var exps = MLList.of_array(exp_ary);\n        return (\n          Unsafe.bind(MLArray.sequence_unsafe(MLArray.map(prealloc, patts)),\n            function (id_ary) {\n              var ids = MLList.of_array(id_ary);\n              var func = function (ctx, id, exp) {\n                var idx = Vector.append(s, Prealloc(exp, ctx));\n                var ctx$ = ExecutionContext.add(id, idx, ctx);\n                Vector.set(s, idx, Prealloc(exp, ctx$));\n                return (ctx$);\n              };\n              var ctx$ = MLList.foldl2(func, ctx, ids, exps);\n              return (run_expression(s, ctx$, e2));}));\n      } else {\n        var func = function (ctx_nsf, patt, exp) {\n          return (\n            Unsafe.bind(ctx_nsf, function (ctx) {\n                return (\n                  Unsafe.bind(run_expression(s, ctx, exp), function (v) {\n                      return (pattern_match(s, ctx, v, patt));}));}));\n        };\n        var patt_list = MLList.of_array(patts);\n        var exps = MLList.of_array(exp_ary);\n        return (\n          Unsafe.bind(MLList.foldl2(func, Unsafe.box(ctx), patt_list, exps),\n            function (ctx$) { return (run_expression(s, ctx$, e2));}));\n      }\n    case Expression_function(cases):\n      var func = function (value) {\n        return (pattern_match_many(s, ctx, value, MLList.of_array(cases)));\n      };\n      return (Unsafe.box(Value_fun(func)));\n    case Expression_apply(fe, argse):\n      var apply_fun = function (func, ctx, arg, args) {\n        return (\n          Unsafe.bind(run_expression(s, ctx, arg), function (v) {\n              return (\n                Unsafe.bind(func(v), function (res) {\n                    return (run_apply(res, args));}));}));\n      };\nvar run_apply = function (func, args) {\n        switch (args) {\n          case []:\n            return (Unsafe.box(func));\n          case (x::xs):\n            switch (func) {\n              case Value_fun(f):\n                return (apply_fun(f, ctx, x, xs));\n              default:\n                return (Unsafe.error("Expected a function value"));\n            }\n            \n        }\n        \n      };\n      return (\n        Unsafe.bind(run_expression(s, ctx, fe), function (func) {\n            return (run_apply(func, MLList.of_array(argse)));}));\n    case Expression_tuple(tuple):\n      var value_nsfs = MLArray.map(function (e) {\n                           return (run_expression(s, ctx, e));}, tuple);\n      return (\n        Unsafe.bind(MLArray.sequence_unsafe(value_nsfs), function (t) {\n            return (Unsafe.box(Value_tuple(t)));}));\n    case Expression_array(ary):\n      var value_nsfs = MLArray.map(function (e) {\n                           return (run_expression(s, ctx, e));}, ary);\n      return (\n        Unsafe.bind(MLArray.sequence_unsafe(value_nsfs), function (a) {\n            return (Unsafe.box(Value_array(a)));}));\n    case Expression_variant(label, expr_opt):\n      var value_nsf = Unsafe.bind(Unsafe.of_option(expr_opt), function (e) {\n                          return (run_expression(s, ctx, e));});\n      var value_opt = Option.bind(expr_opt, function (e) {\n                          return (Some(value_nsf));});\n      var variant = {\n        label: label,\n        value_opt: value_opt\n      };\n      return (Unsafe.box(Value_variant(variant)));\n    case Expression_match(loc, expr, cases):\n      var func = Expression_function(loc, cases);\n      var app = Expression_apply(loc, func, [expr]);\n      return (run_expression(s, ctx, app));\n    case Expression_constructor(ctor, args):\n      var value_nsfs = MLArray.map(function (e) {\n                           return (run_expression(s, ctx, e));}, args);\n      return (\n        Unsafe.bind(MLArray.sequence_unsafe(value_nsfs), function (values) {\n            var sum = Sumtype({\n                          constructor: string_of_identifier(ctor),\n                          args: values});\n            return (Unsafe.box(Value_custom(sum)));}));\n    case Expression_record(bindings, base_opt):\n      var add_to_map = function (map_nsf, binding) {\n        return (\n          Unsafe.bind(map_nsf, function (map) {\n              return (\n                Unsafe.bind(run_expression(s, ctx, binding.expr),\n                  function (value) {\n                    var idx = Vector.append(s, Normal(value));\n                    return (Unsafe.box(Map.add(binding.name, idx, map)));}));\n            }));\n      };\n      var string_eq = function (s1, s2) {\n        return ((string_compare(s1, s2) === 0));\n      };\n      var empty_map = Map.empty_map(string_eq, function (r) { return (r);});\n      var map_from_value = function (v) {\n        return (\n          do_record_with_default(v, empty_map, function (r) { return (r);}));\n      };\n      var base_map = Unsafe.do_with_default(Unsafe.of_option(base_opt),\n                       empty_map, function (base) {\n                         return (\n                           Unsafe.do_with_default(\n                             run_expression(s, ctx, base), empty_map,\n                             function (v) { return (map_from_value(v));}));});\n      return (\n        Unsafe.bind(MLArray.fold(add_to_map, Unsafe.box(base_map), bindings),\n          function (map) {\n            var r = Record(map);\n            return (Unsafe.box(Value_custom(r)));}));\n    case Expression_field(record, fieldname):\n      return (\n        Unsafe.bind(run_expression(s, ctx, record), function (value) {\n            return (\n              do_record(value, function (record) {\n                  return (\n                    Unsafe.bind(Map.find(fieldname, record), function (idx) {\n                        return (\n                          Unsafe.bind(Vector.find(s, idx),\n                            function (binding) {\n                              return (value_of(s, ctx, binding));}));}));}));\n          }));\n    case Expression_setfield(record, fieldname, expr):\n      return (\n        Unsafe.bind(run_expression(s, ctx, record), function (value) {\n            return (\n              do_record(value, function (record) {\n                  return (\n                    Unsafe.bind(Map.find(fieldname, record), function (idx) {\n                        return (\n                          Unsafe.bind(run_expression(s, ctx, expr),\n                            function (v) {\n                              var ignore = Vector.set(s, idx, Normal(v));\n                              return (Unsafe.box(nil));}));}));}));}));\n    case Expression_ifthenelse(cond, e1, e2):\n      return (\n        Unsafe.bind(run_expression(s, ctx, cond), function (cond_val) {\n            if (is_sumtype_ctor("true", cond_val)) {\n              return (run_expression(s, ctx, e1));\n            } else {\n              return (\n                Unsafe.do_with_default(Unsafe.of_option(e2), Unsafe.box(nil),\n                  function (e) { return (run_expression(s, ctx, e));}));\n            }}));\n    case Expression_sequence(e1, e2):\n      run_expression(s, ctx, e1);\n      return (run_expression(s, ctx, e2));\n    case Expression_while(loc, cond_expr, body):\n      var while_expr = Expression_while(loc, cond_expr, body);\n      return (\n        Unsafe.bind(run_expression(s, ctx, cond_expr), function (cond) {\n            return (\n              do_sumtype(cond, function (b) {\n                  if ((b.constructor === "true")) {\n                    run_expression(s, ctx, body);\n                    return (run_expression(s, ctx, while_expr));\n                  } else {\n                    return (Unsafe.box(nil));\n                  }}));}));\n    case Expression_for(id, fst, lst, dir, body):\n      return (\n        Unsafe.bind(run_expression(s, ctx, fst), function (first) {\n            return (\n              Unsafe.bind(run_expression(s, ctx, lst), function (last) {\n                  var idx = Vector.append(s, Normal(first));\n                  var ctx$ = ExecutionContext.add(id, idx, ctx);\n                  if (dir) {\n                    var step_value = 1;\n                  } else {\n                    var step_value = -1;\n                  }\n                  var step = function (v) {\n                    switch (v) {\n                      case Value_int(i):\n                        return (Unsafe.box(Value_int((i + step_value))));\n                      default:\n                        return (Unsafe.error("Expected an int"));\n                    }\n                    \n                  };\n                  var get_int = function (v) {\n                    switch (v) {\n                      case Value_int(i):\n                        return (Unsafe.box(i));\n                      default:\n                        return (Unsafe.error("Expected an int"));\n                    }\n                    \n                  };\n                  var iter = function (nil) {\n                    return (\n                      Unsafe.bind(Vector.find(s, idx), function (b) {\n                          return (\n                            Unsafe.bind(value_of(s, ctx, b), function (v) {\n                                return (\n                                  Unsafe.bind(get_int(v), function (iv) {\n                                      return (\n                                        Unsafe.bind(get_int(last),\n                                          function (ilast) {\n                                            var fv = iv;\n                                            var flast = ilast;\n                                            if (((dir && (fv <= flast))\n                                                || (!(dir) && (fv >= flast)))) {\n                                              return (\n                                                Unsafe.bind(\n                                                  run_expression(s, ctx$,\n                                                    body), function (res) {\n                                                    return (\n                                                      Unsafe.bind(step(v),\n                                                        function (v$) {\n                                                          Vector.set(s, idx,\n                                                            Normal(v$));\n                                                          return (iter({}));\n                                                        }));}));\n                                            } else {\n                                              return (Unsafe.box(Value.nil));\n                                            }}));}));}));}));\n                  };\n                  return (iter({}));}));}));\n    case Expression_try(expr, cases):\n      var ret = run_expression(s, ctx, expr);\n      switch (ret) {\n        case Exception(x):\n          return (pattern_match_many(s, ctx, x, MLList.of_array(cases)));\n        default:\n          return (ret);\n      }\n      \n    case Expression_letmodule(id, modex, expr):\n      return (\n        Unsafe.bind(run_module_expression(s, ctx, modex), function (md) {\n            var ident = string_of_identifier(id);\n            var idx = Vector.append(s, Normal(md));\n            var ctx$ = ExecutionContext.add(ident, idx, ctx);\n            return (run_expression(s, ctx$, expr));}));\n    case Expression_pack(expr):\n      return (run_module_expression(s, ctx, expr));\n    case Expression_assert(expr):\n      return (\n        Unsafe.bind(run_expression(s, ctx, expr), function (res) {\n            return (\n              Unsafe.bind(bool_of_value(res), function (b) {\n                  if (b) {\n                    return (Unsafe.box(nil));\n                  } else {\n                    return (\n                      Unsafe.except(\n                        Value_exception({\n                            constructor: "Assert_failure",\n                            args: []})));\n                  }}));}));\n  }\n  \n};\n\nvar value_of = function (s, ctx, b) {\n  switch (b) {\n    case Normal(v):\n      return (Unsafe.box(v));\n    case Prealloc(e, ctx$):\n      return (run_expression(s, ctx$, e));\n  }\n  \n};\n\nvar pattern_match = function (s, ctx, value, patt) {\n  switch (patt) {\n    case Pattern_any:\n      return (Unsafe.box(ctx));\n    case Pattern_var(id):\n      var idx = Vector.append(s, Normal(value));\n      return (Unsafe.box(ExecutionContext.add(id, idx, ctx)));\n    case Pattern_constant(c):\n      var v1 = run_constant(c);\n      if (value_eq(v1, value)) {\n        return (Unsafe.box(ctx));\n      } else {\n        return (Unsafe.error("Matching failure"));\n      }\n    case Pattern_tuple(patts):\n      switch (value) {\n        case Value_tuple(tuples):\n          return (pattern_match_array(s, ctx, tuples, patts));\n        default:\n          return (Unsafe.error("Expected a tuple"));\n      }\n      \n    case Pattern_array(patts):\n      switch (value) {\n        case Value_array(ary):\n          if ((MLArray.length(patts) === MLArray.length(ary))) {\n            return (pattern_match_array(s, ctx, ary, patts));\n          } else {\n            return (Unsafe.error("Array lengths don\'t match"));\n          }\n        default:\n          return (Unsafe.error("Expected an array"));\n      }\n      \n    case Pattern_variant(label, patt_opt):\n      switch (value) {\n        case Value_variant(variant):\n          if ((variant.label === label)) {\n            switch (patt_opt) {\n              case None:\n                switch (variant.value_opt) {\n                  case None:\n                    return (Unsafe.box(ctx));\n                  case Some:\n                    return (\n                      Unsafe.error("Unexpected argument for the variant"));\n                }\n                \n              case Some(patt):\n                switch (variant.value_opt) {\n                  case None:\n                    return (\n                      Unsafe.error("Expected an argument for the variant"));\n                  case Some(v_nsf):\n                    return (\n                      Unsafe.bind(v_nsf, function (v) {\n                          return (pattern_match(s, ctx, v, patt));}));\n                }\n                \n            }\n            \n          } else {\n            return (Unsafe.error("Matching failure"));\n          }\n        default:\n          return (Unsafe.error("Matching failure"));\n      }\n      \n    case Pattern_alias(subpatt, alias):\n      return (\n        Unsafe.bind(pattern_match(s, ctx, value, subpatt), function (ctx$) {\n            var idx = Vector.append(s, Normal(value));\n            return (Unsafe.box(ExecutionContext.add(alias, idx, ctx$)));}));\n    case Pattern_constructor(ctor, args):\n      return (\n        do_sumtype(value, function (sum) {\n            if ((sum.constructor === string_of_identifier(ctor))) {\n              return (pattern_match_array(s, ctx, sum.args, args));\n            } else {\n              return (Unsafe.error("Matching failure"));\n            }}));\n    case Pattern_or(patt1, patt2):\n      return (\n        Unsafe.do_with_default(pattern_match(s, ctx, value, patt1),\n          pattern_match(s, ctx, value, patt2), function (ctx$) {\n            return (Unsafe.box(ctx$));}));\n  }\n  \n};\n\nvar pattern_match_many = function (s, ctx, value, cases) {\n  switch (cases) {\n    case []:\n      return (Unsafe.error("Matching failure"));\n    case (x::xs):\n      switch (pattern_match(s, ctx, value, x.patt)) {\n        case Error(e):\n          return (pattern_match_many(s, ctx, value, xs));\n        case Result(ctx$):\n          switch (x.guard) {\n            case None:\n              return (run_expression(s, ctx$, x.expr));\n            case Some(guard):\n              return (\n                Unsafe.bind(run_expression(s, ctx$, guard), function (res) {\n                    return (\n                      Unsafe.bind(bool_of_value(res), function (b) {\n                          if (b) {\n                            return (run_expression(s, ctx$, x.expr));\n                          } else {\n                            return (pattern_match_many(s, ctx, value, xs));\n                          }}));}));\n          }\n          \n        case Exception(ex):\n          return (Unsafe.Exception(ex));\n      }\n      \n  }\n  \n};\n\nvar pattern_match_array = function (s, ctx, ary, patts) {\n  var len = MLArray.length(patts);\n  var vallen = MLArray.length(ary);\n  var flen = len;\n  var fvallen = vallen;\n  var min_len = int_of_number(min(flen, fvallen));\n  var for_loop = function (ctx_nsf, i) {\n    if ((i === min_len)) {\n      return (ctx_nsf);\n    } else {\n      var some_case_func = function (ctx) {\n        var vali = MLArray.get(ary, i);\n        var patti = MLArray.get(patts, i);\n        return (for_loop(pattern_match(s, ctx, vali, patti), (i + 1)));\n      };\n      return (Unsafe.bind(ctx_nsf, some_case_func));\n    }\n  };\n  return (for_loop(Unsafe.box(ctx), 0));\n};\n\nvar run_structure_item = function (s, ctx, _term_) {\n  switch (_term_) {\n    case Structure_eval(e):\n      return (\n        Unsafe.bind(run_expression(s, ctx, e), function (v) {\n            return (Unsafe.box({ value: v,\n                                 ctx: ctx}));}));\n    case Structure_value(is_rec, patts, exp_ary):\n      if (is_rec) {\n        var prealloc = function (p) {\n          switch (p) {\n            case Pattern_var(id):\n              return (Unsafe.box(id));\n            default:\n              return (\n                Unsafe.error(\n                  "Used a pattern other than variable in recursive definition"));\n          }\n          \n        };\n        var exps = MLList.of_array(exp_ary);\n        var prealloc_vars = MLArray.map(prealloc, patts);\n        return (\n          Unsafe.bind(MLArray.sequence_unsafe(prealloc_vars),\n            function (id_ary) {\n              var ids = MLList.of_array(id_ary);\n              var func = function (ctx, id, exp) {\n                var idx = Vector.append(s, Prealloc(exp, ctx));\n                var ctx$ = ExecutionContext.add(id, idx, ctx);\n                Vector.set(s, idx, Prealloc(exp, ctx$));\n                return (ctx$);\n              };\n              var ctx$ = MLList.foldl2(func, ctx, ids, exps);\n              var id = MLArray.get(id_ary, (MLArray.length(id_ary) - 1));\n              return (\n                Unsafe.bind(ExecutionContext.find(id, ctx$), function (idx) {\n                    return (\n                      Unsafe.bind(Vector.find(s, idx), function (binding) {\n                          return (\n                            Unsafe.bind(value_of(s, ctx$, binding),\n                              function (v) {\n                                return (Unsafe.box({ value: v,\n                                                     ctx: ctx$}));}));}));}));\n            }));\n      } else {\n        var func = function (ctx_nsf, patt, exp) {\n          return (\n            Unsafe.bind(ctx_nsf, function (ctx) {\n                return (\n                  Unsafe.bind(run_expression(s, ctx, exp), function (v) {\n                      return (pattern_match(s, ctx, v, patt));}));}));\n        };\n        var patt_list = MLList.of_array(patts);\n        var exps = MLList.of_array(exp_ary);\n        return (\n          Unsafe.bind(MLList.foldl2(func, Unsafe.box(ctx), patt_list, exps),\n            function (ctx$) {\n              var elems = Map.elems(\n                            ExecutionContext.execution_ctx_lexical_env(ctx$));\n              var rev_elems = MLList.rev(elems);\n              switch (rev_elems) {\n                case []:\n                  throw false;\n                  break;\n                case (h::t):\n                  var idx_opt = Unsafe.box(h);\n                  break;\n              }\n              \n              return (\n                Unsafe.bind(idx_opt, function (idx) {\n                    return (\n                      Unsafe.bind(Vector.find(s, idx), function (last) {\n                          return (\n                            Unsafe.bind(value_of(s, ctx$, last),\n                              function (v) {\n                                return (Unsafe.box({ value: v,\n                                                     ctx: ctx$}));}));}));}));\n            }));\n      }\n    case Structure_type:\n      return (Unsafe.box({ value: nil,\n                           ctx: ctx}));\n    case Structure_module(id, expr):\n      return (\n        Unsafe.bind(run_module_expression(s, ctx, expr), function (m) {\n            var idx = Vector.append(s, Normal(m));\n            var ctx$ = ExecutionContext.add(id, idx, ctx);\n            return (Unsafe.box({ value: m,\n                                 ctx: ctx$}));}));\n    case Structure_modtype:\n      return (Unsafe.box({ value: nil,\n                           ctx: ctx}));\n    case Structure_include(expr):\n      return (\n        Unsafe.bind(run_module_expression(s, ctx, expr), function (value) {\n            switch (value) {\n              case Value_struct(str):\n                var map = Map.union(str,\n                            ExecutionContext.execution_ctx_lexical_env(ctx));\n                return (\n                  Unsafe.box({ value: nil,\n                               ctx: ExecutionContext.from_map(map)}));\n              default:\n                return (Unsafe.error("Expected a module value"));\n            }\n            }));\n    case Structure_primitive:\n      return (Unsafe.box({ value: nil,\n                           ctx: ctx}));\n    case Structure_exception:\n      return (Unsafe.box({ value: nil,\n                           ctx: ctx}));\n    case Structure_open(id):\n      return (\n        Unsafe.bind(run_ident(s, ctx, id), function (v) {\n            switch (v) {\n              case Value_struct(md):\n                return (\n                  Unsafe.box({\n                      value: nil,\n                      ctx: ExecutionContext.open_module(id, md, ctx)}));\n              default:\n                return (Unsafe.error("Expected a module"));\n            }\n            }));\n  }\n  \n};\n\nvar run_module_expression = function (s, ctx, _term_) {\n  switch (_term_) {\n    case Module_ident(id):\n      return (run_ident(s, ctx, id));\n    case Module_structure(str):\n      return (\n        Unsafe.bind(run_structure(s, ctx, str), function (res) {\n            var map = ExecutionContext.execution_ctx_lexical_env(res.ctx);\n            return (Unsafe.box(Value_struct(map)));}));\n    case Module_functor(id, expr):\n      var func = function (varg) {\n        var idx = Vector.append(s, Normal(varg));\n        var ctx$ = ExecutionContext.add(id, idx, ctx);\n        return (run_module_expression(s, ctx$, expr));\n      };\n      return (Unsafe.box(Value_functor(func)));\n    case Module_apply(f, e):\n      return (\n        Unsafe.bind(run_module_expression(s, ctx, f), function (func) {\n            return (\n              Unsafe.bind(run_module_expression(s, ctx, e), function (expr) {\n                  switch (func) {\n                    case Value_functor(fctor):\n                      return (fctor(expr));\n                    default:\n                      return (Unsafe.error("Expected a functor"));\n                  }\n                  }));}));\n    case Module_constraint(expr):\n      return (run_module_expression(s, ctx, expr));\n    case Module_unpack(expr):\n      return (run_expression(s, ctx, expr));\n  }\n  \n};\n\nvar run_structure = function (s, ctx, _term_) {\n  var func = function (nsf, _term_) {\n    return (\n      Unsafe.bind(nsf, function (res) {\n          return (run_structure_item(s, res.ctx, _term_));}));\n  };\n  var fake_res = Unsafe.box({ value: nil,\n                              ctx: ctx});\n  switch (_term_) {\n    case Structure(items):\n      return (MLArray.fold(func, fake_res, items));\n  }\n  \n};\n\nvar run = function (s, ctx, _term_) {\n  return (\n    Unsafe.bind(run_structure(s, ctx, _term_), function (res) {\n        return (Unsafe.box(res.ctx));}));\n};\n}// end of with MLSyntax\n}// end of with Value\n}// end of with Identifier\n\nreturn {\n  min: min, \n  build_initial_env: build_initial_env, \n  string_of_identifier: string_of_identifier, \n  run_constant: run_constant, \n  run_ident: run_ident, \n  run_expression: run_expression, \n  value_of: value_of, \n  pattern_match: pattern_match, \n  pattern_match_many: pattern_match_many, \n  pattern_match_array: pattern_match_array, \n  run_structure_item: run_structure_item, \n  run_module_expression: run_module_expression, \n  run_structure: run_structure, \n  run: run};\n})();\n'},

/* --------------------- MLInterpreter.ml --------------------- */
  { file: 'MLInterpreter.ml', contents: 'open MLSyntax\nopen Value\nopen Identifier\n\nlet min a b = if a <= b then a else b\n\ntype environment = ExecutionContext.execution_ctx\n\ntype structure_item_result = {\n  value : value ;\n  ctx : environment\n}\n\n(** Build the Pervasives module *)\nlet build_initial_env s ctx =\n  let func ctx builtin =\n    let name = builtin_name builtin in\n    let value = builtin_value builtin in\n    let idx = Vector.append s (Normal value) in\n    ExecutionContext.add name idx ctx in\n  MLList.foldl func ctx Value.initial_env\n\nlet rec string_of_identifier = function\n| Lident id -> id\n| Ldot (path, id) -> strappend (strappend (string_of_identifier path) ".") id\n\n(** Evaluate a constant expression.\n * This function is trivial, constants are evaluated to their corresponding value *)\nlet run_constant = function\n| Constant_integer i -> Value_int i\n| Constant_float f -> Value_float f\n| Constant_char c -> Value_char c\n| Constant_string s -> Value_string (normalize_string s)\n\n(** Get the value pointed by the given identifier. *)\nlet rec run_ident s ctx str = match str with\n(* An id is a variable\'s name, supposedly accessible from the current context.\n * The id is looked up in the execution context to retrieve the corresponding index,\n * then the value corresponding to this index is retrieved from the program\'s state. *)\n| Lident id ->\n  let%result idx = ExecutionContext.find id ctx in\n  let%result b = Vector.find s idx in\n  value_of s ctx b\n(* A dot identifier is a path to an id in a sub-module.\n * (e.g. "foo.bar" represents the id "bar" in the sub-module "foo")\n * The path is resolved recursively to get the module in which the id is supposed to be stored,\n * then the id is looked up in the the module\'s context to get its value. *)\n| Ldot (path, id) ->\n  let%result value = run_ident s ctx path in\n  match value with\n  | Value_struct m ->\n    (* The computed path should lead to a module struct\n     * The id is looked up in this module\'s context *)\n    let%result idx = Map.find id m in\n    let%result b = Vector.find s idx in\n    value_of s ctx b\n  | _ -> Unsafe.error "Try to get attribute from non-module value"\n\n(** Evaluate an expression and get the computed value. *)\nand run_expression s ctx _term_ = match _term_ with\n(* A constant expression is evaluated to its own value. *)\n| Expression_constant (_, c) -> Unsafe.box (run_constant c)\n(* To get the value pointed by an identifier, the entire path it describes must be resolved. *)\n| Expression_ident (_, id) -> run_ident s ctx id\n(* A let expression may be evaluated differently whether it is recursive or not.\n * In the case it is recursive, the variable must be pre-allocated so its identifier\n * can exist in its own expression\'s context. *)\n| Expression_let (_, is_rec, patts, exp_ary, e2) ->\n  if is_rec then\n    (* In a recursive definition, the identifiers involved are pre-allocated\n     * This function makes the list of identifiers to pre-allocate *)\n    let prealloc p = match p with\n    | Pattern_var (_, id) -> Unsafe.box id\n    | _ -> Unsafe.error "Used pattern other than variable in recursive definition" in\n    let exps = MLList.of_array exp_ary in\n    (* Get the list of ids, since complex patterns are not supported in recursive definitions. *)\n    let%result id_ary = MLArray.sequence_unsafe (MLArray.map prealloc patts) in\n    let ids = MLList.of_array id_ary in\n    (* Pre-allocate each variable. *)\n    let func ctx id exp =\n      let idx = Vector.append s (Prealloc (exp, ctx)) in\n      let ctx\' = ExecutionContext.add id idx ctx in\n      Vector.set s idx (Prealloc (exp, ctx\')) ; ctx\' in\n    (* Add the identifiers to the current context. *)\n    let ctx\' = MLList.foldl2 func ctx ids exps in\n    (* Evaluate the expression "in" with every variables defined pre-allocated. *)\n    run_expression s ctx\' e2\n  else\n    (* The function matches the pattern with the expression and returns the generated context *)\n    let func ctx_nsf patt exp =\n      let%result ctx = ctx_nsf in\n      let%result v = run_expression s ctx exp in\n      pattern_match s ctx v patt in\n    let patt_list = MLList.of_array patts in\n    let exps = MLList.of_array exp_ary in\n    (* Generate a context containing every definition *)\n    let%result ctx\' = MLList.foldl2 func (Unsafe.box ctx) patt_list exps in\n    (* Evaluate the expression "in" with the generated context. *)\n    run_expression s ctx\' e2\n(* A function definition is evaluated to a function (in the interpreter world) that matches\n * each pattern of the function with the value given as argument\n * and evaluates the corresponding expression. *)\n| Expression_function (_, cases) ->\n  let func value = pattern_match_many s ctx value (MLList.of_array cases) in\n  Unsafe.box (Value_fun func)\n(* To apply a function to the given arguments, the actual function is applied to the first argument.\n * The resulting value should be a function that takes the following argument and so on until\n * there is no pending argument to consume. The resulting value is returned. *)\n| Expression_apply (_, fe, argse) ->\n  let rec apply_fun func ctx arg args =\n    let%result v = run_expression s ctx arg in\n    let%result res = func v in\n    run_apply res args\n  and run_apply func args =\n    match args with\n    (* No argument means a value to return *)\n    | [] -> Unsafe.box func\n    (* Having arguments means that we have to apply a function to them *)\n    | x :: xs ->\n      match func with\n      | Value_fun f -> apply_fun f ctx x xs\n      | _ -> Unsafe.error "Expected a function value" in\n\n    let%result func = run_expression s ctx fe in\n    run_apply func (MLList.of_array argse)\n(* A tuple is the result of the evaluation of its components. *)\n| Expression_tuple (_, tuple) ->\n  let value_nsfs = MLArray.map (fun e -> run_expression s ctx e) tuple in\n  let%result t = MLArray.sequence_unsafe value_nsfs in\n  Unsafe.box (Value_tuple t)\n(* An array is constructed from the evaluation of its components. *)\n| Expression_array (_, ary) ->\n  let value_nsfs = MLArray.map (fun e -> run_expression s ctx e) ary in\n  let%result a = MLArray.sequence_unsafe value_nsfs in\n  Unsafe.box (Value_array a)\n(* A variant is stored as its label and its value if any. *)\n| Expression_variant (_, label, expr_opt) ->\n  let value_nsf =\n    let%result e = Unsafe.of_option expr_opt in\n    run_expression s ctx e in\n  (* The value is kept only if there was an expression beforehand *)\n  let value_opt =\n    let%some e = expr_opt in\n    Some value_nsf in\n  let variant = { label = label ; value_opt = value_opt } in\n  Unsafe.box (Value_variant variant)\n(* Since a match ... with expression is equivalent to the application of the corresponding lambda function,\n * it is evaluated the exact same way. *)\n| Expression_match (loc, expr, cases) ->\n  let func = Expression_function (loc, cases) in\n  let app = Expression_apply (loc, func, [| expr |]) in\n  run_expression s ctx app\n(* Sumtype instances are evaluated like variants except it builds a Sumtype value and\n * sumtype constructors accept several values as arguments *)\n| Expression_constructor (_, ctor, args) ->\n  let value_nsfs = MLArray.map (fun e -> run_expression s ctx e) args in\n  let%result values =  MLArray.sequence_unsafe value_nsfs in\n  let sum = Sumtype { constructor = string_of_identifier ctor ; args = values } in\n  Unsafe.box (Value_custom sum)\n(* A record has a field set and a base. The base is the record specified by the "with" syntax\n * (or an empty field set if no base has been specified).\n * The bindings here are the fields that are updated, they override the corresponding fields\n * in the provided base. *)\n| Expression_record (_, bindings, base_opt) ->\n  (* Function that adds the given binding to the map if it is valid. *)\n  let add_to_map map_nsf binding =\n    let%result map = map_nsf in\n    let%result value = run_expression s ctx binding.expr in\n    let idx = Vector.append s (Normal value) in\n    Unsafe.box (Map.add binding.name idx map) in\n  let string_eq s1 s2 = string_compare s1 s2 === 0 in\n  let empty_map = Map.empty_map string_eq (fun r -> r) in\n  (* If the value is a record, the function is applied, otherwise the default value is returned *)\n  let map_from_value v = do_record_with_default v empty_map (fun r -> r) in\n  (* The map of bindings of the base record. *)\n  let base_map =\n    Unsafe.do_with_default (Unsafe.of_option base_opt) empty_map (fun base ->\n    Unsafe.do_with_default (run_expression s ctx base) empty_map (fun v ->\n    map_from_value v)) in\n  let%result map = MLArray.fold add_to_map (Unsafe.box base_map) bindings in\n  (* Create the new record. *)\n  let r = Record map in\n  Unsafe.box (Value_custom r)\n(* To retrieve a field from a record, the expression corresponding to the record is evaluated,\n * then the field name is looked up in the map of bindings of this record. *)\n| Expression_field (_, record, fieldname) ->\n  let%result value = run_expression s ctx record in\n  do_record value (fun record ->\n    let%result idx = Map.find fieldname record in\n    let%result binding = Vector.find s idx in\n    value_of s ctx binding)\n(* To update a field in a record, the record expression\'s value is computed then the index\n * of the state where the value of the field is stored is retrieved. Finally the value at\n * this index is updated. *)\n| Expression_setfield (_, record, fieldname, expr) ->\n  let%result value = run_expression s ctx record in\n  do_record value (fun record ->\n    let%result idx = Map.find fieldname record in\n    let%result v = run_expression s ctx expr in\n      let ignore = Vector.set s idx (Normal v) in\n      Unsafe.box nil)\n(* To evaluate a conditional expression, the condition expression is evaluated and depending on\n * the resulting value the first expression or the second one is evaluated.\n * There may not be a second expression, in this case, nothing is done and\n * the conditional expression returns nil. *)\n| Expression_ifthenelse (_, cond, e1, e2) ->\n  let%result cond_val = run_expression s ctx cond in\n    if is_sumtype_ctor "true" cond_val then\n      run_expression s ctx e1\n    else\n      Unsafe.do_with_default (Unsafe.of_option e2) (Unsafe.box nil) (fun e -> run_expression s ctx e)\n(* Evaluating a sequence of two expressions is equivalent to evaluate the first one,\n * discard the result and finally evaluate the second one. *)\n| Expression_sequence (_, e1, e2) ->\n  run_expression s ctx e1 ;\n  run_expression s ctx e2\n(* The evaluation of a while loop is recursive. First the condition is evaluated and if the result\n * is false, it returns nil. If the result is true, the body of the loop is evaluated and\n * the whole while-loop exression is re-evaluated as is.\n * The reason why it does not loop infinitely is because the state of the program may (should)\n * be modify at each iteration of the loop, making the condition expression evaluate differently *)\n| Expression_while (loc, cond_expr, body) ->\n  (* Alias pattern not supported by the compiler *)\n  let while_expr = Expression_while (loc, cond_expr, body) in\n  let%result cond = run_expression s ctx cond_expr in\n  do_sumtype cond (fun b ->\n  if b.constructor === "true" then\n  begin\n    run_expression s ctx body ;\n    run_expression s ctx while_expr\n  end\n  else\n    (* While loops ultimately return nil *)\n    Unsafe.box nil)\n(* For loops are complex in OCaml since the iteration can go upward or downward depending on\n * the keyword used ("to" or "downto"). To solve this problem a function "step"\n * computes the value for the next iteration. Then the value the variable takes at the beginning\n * and the value it is to reach are computed. The variable is created in the state and the context.\n * Finally the body is evaluated until the variable reach its final value. *)\n| Expression_for (_, id, fst, lst, dir, body) ->\n  let%result first = run_expression s ctx fst in\n  let%result last = run_expression s ctx lst in\n  (* Create a new object in the program\'s state and add a reference to it in the context\n   * val <id> : int = <first> (and stored in the state at index <idx>) *)\n  let idx = Vector.append s (Normal first) in\n  let ctx\' = ExecutionContext.add id idx ctx in\n  let step_value = if dir then 1 else -1 in\n  let step v = match v with\n  | Value_int i -> Unsafe.box (Value_int (i + step_value))\n  | _ -> Unsafe.error "Expected an int" in\n  let get_int v = match v with\n  | Value_int i -> Unsafe.box i\n  | _ -> Unsafe.error "Expected an int" in\n  (* Main function of the for-loop interpretation.\n   * It evaluates the body of the loop iff its variant is true. *)\n  let rec iter nil =\n    let%result b = Vector.find s idx in\n    let%result v = value_of s ctx b in\n    let%result iv = get_int v in\n    let%result ilast = get_int last in\n    (* Mandatory conversion to floats to use operators < and > *)\n    let fv = number_of_int iv in\n    let flast = number_of_int ilast in\n    (* Check whether fv has reached flast depending on the direction *)\n    if (dir && fv <= flast) || (not dir && fv >= flast) then\n      let%result res = run_expression s ctx\' body in\n      let%result v\' = step v in\n       \n      (* The body is executed in the Unsafe monad to propagate errors *)\n      Vector.set s idx (Normal v\') ;\n      iter ()\n    else\n      (* A for loop returns uni *)\n      Unsafe.box Value.nil in\n  iter ()\n(* Try expressions are meant to catch exceptions. Since exceptions are represented by\n * a constructor of the type Unsafe.t in the interpreter, the watched expression is\n * evaluated normally and the result is filtered. *)\n| Expression_try (_, expr, cases) ->\n  let ret = run_expression s ctx expr in\n  begin\n    match ret with\n    | Unsafe.Exception x -> pattern_match_many s ctx x (MLList.of_array cases)\n    | _ -> ret\n  end\n(* Let-module expressions are almost the same as simple let expressions since\n * the internal representation of first-class modules and classical modules is\n * identical. *)\n| Expression_letmodule (_, id, modex, expr) ->\n  let%result md = run_module_expression s ctx modex in\n  let ident = string_of_identifier id in\n  let idx = Vector.append s (Normal md) in\n  let ctx\' = ExecutionContext.add ident idx ctx in\n  run_expression s ctx\' expr\n(* Internal representation of first-class modules is the same as classical modules.\n * There is thus nothing to do to pack a module. *)\n| Expression_pack (_, expr) -> run_module_expression s ctx expr\n(* Assertions throw an exception if the given expression evaluates to false.\n * The expression is therefore evaluated and the result value is checked.\n * A nil value is sent in case of success, an Assert_failure is thrown otherwise. *)\n| Expression_assert (_, expr) ->\n  let%result res = run_expression s ctx expr in\n  let%result b = bool_of_value res in\n  if b then\n    Unsafe.box nil\n  else\n    Unsafe.except (Value_exception { constructor = "Assert_failure" ; args = [| |] })\n\n(** Get the actual value held by the binding b *)\nand value_of s ctx b = match b with\n(* A normal value is already computed. *)\n| Normal v -> Unsafe.box v\n(* A pre-allocated value needs to be computed. *)\n| Prealloc (e, ctx\') -> run_expression s ctx\' e\n\n(** Match the given value with the given pattern to get a new execution context. *)\nand pattern_match s ctx value patt = match patt with\n(* The pattern _ matches any pattern and leave the context unchanged. *)\n| Pattern_any _ -> Unsafe.box ctx\n(* The variable pattern matches any pattern and bind the value to the given identifier. *)\n| Pattern_var (_, id) ->\n  let idx = Vector.append s (Normal value) in\n  Unsafe.box (ExecutionContext.add id idx ctx)\n(* The constant pattern matches its exact value only and leave the context unchanged. *)\n| Pattern_constant (_, c) ->\n  let v1 = run_constant c in\n  if value_eq v1 value then Unsafe.box ctx else Unsafe.error "Matching failure"\n(* The tuple pattern expects a tuple value and match each of its components to\n * the tuple value\'s components *)\n| Pattern_tuple (_, patts) ->\n  begin\n    match value with\n    (* No need to check if the pattern has the same number of components as the value\n     * since the typing prevent different-length tuple matching *)\n    | Value_tuple tuples -> pattern_match_array s ctx tuples patts\n    | _ -> Unsafe.error "Expected a tuple"\n  end\n| Pattern_array (_, patts) ->\n  begin\n    match value with\n    | Value_array ary ->\n      if MLArray.length patts === MLArray.length ary then\n        pattern_match_array s ctx ary patts\n      else\n        Unsafe.error "Array lengths don\'t match"\n    | _ -> Unsafe.error "Expected an array"\n  end\n| Pattern_variant (_, label, patt_opt) ->\n  begin\n    match value with\n    | Value_variant variant ->\n      if variant.label === label then\n        match patt_opt with\n        | None ->\n          begin\n            match variant.value_opt with\n            | None -> Unsafe.box ctx\n            | Some _ -> Unsafe.error "Unexpected argument for the variant"\n          end\n        | Some patt ->\n          begin\n            match variant.value_opt with\n            | None -> Unsafe.error "Expected an argument for the variant"\n            | Some v_nsf ->\n              let%result v = v_nsf in\n              pattern_match s ctx v patt\n          end\n      else\n        Unsafe.error "Matching failure"\n    | _ -> Unsafe.error "Matching failure"\n  end\n(* An alias binds the value to another identifier in addition to the bindings\n * the matching of the pattern may have made. *)\n| Pattern_alias (_, subpatt, alias) ->\n  let%result ctx\' = pattern_match s ctx value subpatt in\n  let idx = Vector.append s (Normal value) in\n  Unsafe.box (ExecutionContext.add alias idx ctx\')\n(* To match a constructor pattern, the value\'s contructor must be the same as\n * the pattern\'s one and the value\'s arguments must match the argument patterns. *)\n| Pattern_constructor (_, ctor, args) ->\n  do_sumtype value (fun sum ->\n    if sum.constructor === string_of_identifier ctor then\n      pattern_match_array s ctx sum.args args\n    else\n      Unsafe.error "Matching failure")\n(* In a disjonctive pattern, if the value does not match the first pattern,\n * it must match the second. *)\n| Pattern_or (_, patt1, patt2) ->\n  Unsafe.do_with_default (pattern_match s ctx value patt1)\n    (pattern_match s ctx value patt2) (* default value *)\n    (fun ctx\' -> Unsafe.box ctx\') (* function to apply *)\n\n(** Try many pattern one after the other until the value matches one. *)\nand pattern_match_many s ctx value cases = match cases with\n| [] -> Unsafe.error "Matching failure"\n| x :: xs ->\n  match pattern_match s ctx value x.patt with\n  | Unsafe.Error e -> pattern_match_many s ctx value xs\n  | Unsafe.Result ctx\' ->\n    begin\n      match x.guard with\n      | None -> run_expression s ctx\' x.expr\n      | Some guard ->\n        let%result res = run_expression s ctx\' guard in\n        let%result b = bool_of_value res in\n        if b then\n          run_expression s ctx\' x.expr\n        else\n          pattern_match_many s ctx value xs\n    end\n  | Unsafe.Exception ex -> Unsafe.Exception ex\n\n(** Match each value of the array with the corresponding pattern in the pattern array. *)\nand pattern_match_array s ctx ary patts =\n  let len = MLArray.length patts in\n  let vallen = MLArray.length ary in\n\n  let flen = number_of_int len in\n  let fvallen = number_of_int vallen in\n  let min_len = int_of_number (min flen fvallen) in\n\n  (* For each i in 0 to len,\n   * the value i is matched with the pattern i to populate the new environment *)\n  let rec for_loop ctx_nsf i =\n    if i === min_len then\n      (* terminal case, the resulting environment is returned *)\n      ctx_nsf\n    else\n      let some_case_func ctx =\n        let vali = (MLArray.get ary i) in\n        let patti = (MLArray.get patts i) in\n        for_loop (pattern_match s ctx vali patti) (i + 1) in\n      (* ctx_nsf >>= some_case_func *)\n      Unsafe.bind ctx_nsf some_case_func in\n   for_loop (Unsafe.box ctx) 0\n\n(** Evaluate a toplevel phrase and return the computed value if any and the new context. *)\nand run_structure_item s ctx _term_ = match _term_ with\n(* Evaluate a core expression. *)\n| Structure_eval (_, e) ->\n  let%result v = run_expression s ctx e in\n  Unsafe.box { value = v ; ctx = ctx }\n(* Toplevel let bindings the same as core-expression-level let bindings. *)\n| Structure_value (_, is_rec, patts, exp_ary) ->\n  (* The data is recursive, a Prealloc binding is generated *)\n  if is_rec then\n    (* Prealloc only accept variable patterns *)\n    let prealloc p = match p with\n    | Pattern_var (_, id) -> Unsafe.box id\n    | _ -> Unsafe.error "Used a pattern other than variable in recursive definition" in\n    let exps = MLList.of_array exp_ary in\n    let prealloc_vars = MLArray.map prealloc patts in\n    let%result id_ary = MLArray.sequence_unsafe prealloc_vars in\n    let ids = MLList.of_array id_ary in\n    (* Auxiliary function adding a Prealloc of exp bound to id in the given context *)\n    let func ctx id exp =\n      let idx = Vector.append s (Prealloc (exp, ctx)) in\n      let ctx\' = ExecutionContext.add id idx ctx in\n      Vector.set s idx (Prealloc (exp, ctx\')) ; ctx\' in\n    (* Foldl of the lists simultaneously using func and the current context *)\n    let ctx\' = MLList.foldl2 func ctx ids exps in\n    (* Return the last value bound by this toplevel phrase *)\n    let id = MLArray.get id_ary (MLArray.length id_ary - 1) in\n    let%result idx = ExecutionContext.find id ctx\' in\n    let%result binding = Vector.find s idx in\n    let%result v = value_of s ctx\' binding in\n    Unsafe.box { value = v ; ctx = ctx\' }\n  else\n    let func ctx_nsf patt exp =\n      let%result ctx = ctx_nsf in\n      let%result v = run_expression s ctx exp in\n      pattern_match s ctx v patt in\n    let patt_list = MLList.of_array patts in\n    let exps = MLList.of_array exp_ary in\n    (* Generate a new environment binding patterns\' variable to their respective value *)\n    let%result ctx\' = MLList.foldl2 func (Unsafe.box ctx) patt_list exps in\n    (* Get the value to return *)\n    let elems = Map.elems (ExecutionContext.execution_ctx_lexical_env ctx\') in\n    let rev_elems = MLList.rev elems in\n    let idx_opt = match rev_elems with\n    | [] -> assert false\n    | h :: t -> Unsafe.box h in\n\n    let%result idx = idx_opt in\n    let%result last = Vector.find s idx in\n    let%result v = value_of s ctx\' last in\n    Unsafe.box { value = v ; ctx = ctx\' }\n(* Type definitions are handled at type-checking pass, so there is nothing more to do\n * at this moment of the execution. *)\n| Structure_type _ -> Unsafe.box { value = nil ; ctx = ctx }\n(* The definition of a module requires the evaluation of the module expression\n * and then the module expression is bound to an identifier. *)\n| Structure_module (_, id, expr) ->\n  let%result m = run_module_expression s ctx expr in\n  let idx = Vector.append s (Normal m) in\n  let ctx\' = ExecutionContext.add id idx ctx in\n  Unsafe.box { value = m ; ctx = ctx\' }\n(* The definition of a module type is handled during the type checking, so\n * there is nothing more to do at this point. *)\n| Structure_modtype _ -> Unsafe.box { value = nil ; ctx = ctx }\n(* To include a module, its contents must be added to the current context. *)\n| Structure_include (_, expr) ->\n  let%result value = run_module_expression s ctx expr in\n  begin\n    match value with\n    | Value_struct str ->\n      (* Add the contents of the module to the current context *)\n      let map = Map.union str (ExecutionContext.execution_ctx_lexical_env ctx) in\n      Unsafe.box { value = nil ; ctx = ExecutionContext.from_map map }\n    | _ -> Unsafe.error "Expected a module value"\n  end\n(* Both primitive and exception definitions are handled during the type checking. *)\n| Structure_primitive _ -> Unsafe.box { value = nil ; ctx = ctx }\n| Structure_exception _ -> Unsafe.box { value = nil ; ctx = ctx }\n(* Opening a module does not mean that its contents are added to the current context,\n * it means that they are made available. In this interpreter, when the context is browsed\n * via the find function, it browses the current context and if no satisfying binding\n * is found, it browses the map of each opened module.\n * Therefore, opening a module in this interpreter is adding it to the list of opened modules\n * of the current context. *)\n| Structure_open (_, id) ->\n  let%result v = run_ident s ctx id in\n  match v with\n  | Value_struct md -> Unsafe.box { value = nil ; ctx = ExecutionContext.open_module id md ctx }\n  | _ -> Unsafe.error "Expected a module"\n\n(** Evaluate a module expression and return the computed value. *)\nand run_module_expression s ctx _term_ = match _term_ with\n(* An identifier implies a reference to another module, so the value this identifier holds\n * is retrieved. *)\n| Module_ident (_, id) -> run_ident s ctx id\n(* Structures are the main module expressions. They are a set of definitions and evaluations.\n * Each phrase in the structure is executed and the resulting module is returned.\n * The resulting module contains the execution context as it was at end of the structure\'s\n * evalutation. *)\n| Module_structure (_, str) ->\n  (* Run the structure and put the returned context in the struct value *)\n  let%result res = run_structure s ctx str in\n  let map = ExecutionContext.execution_ctx_lexical_env res.ctx in\n  Unsafe.box (Value_struct map)\n(* Functors are functions that take a module as argument and return a new module. Obviously,\n * a functor\'s definition computes a function with the same behavior. *)\n| Module_functor (_, id, expr) ->\n  (* The function that takes the module as argument and returns the new one. *)\n  let func varg =\n    let idx = Vector.append s (Normal varg) in\n    let ctx\' = ExecutionContext.add id idx ctx in\n    run_module_expression s ctx\' expr in\n  Unsafe.box (Value_functor func)\n(* The application of a functor to a module is similar to the application of a function\n * to a value. The functor\'s value and the argument\'s value are computed and then\n * the functor is applied to the argument. *)\n| Module_apply (_, f, e) ->\n  let%result func = run_module_expression s ctx f in\n  let%result expr = run_module_expression s ctx e in\n  begin \n    match func with\n    | Value_functor fctor -> fctor expr\n    | _ -> Unsafe.error "Expected a functor"\n  end\n(* Constraints are handled during the type checking pass, so there is nothing more to do. *)\n| Module_constraint (_, expr) -> run_module_expression s ctx expr\n(* Module unpacking is all about making a module from a first-class module.\n * The given expression is evaluated and should return a module value. Since modules and first-class\n * modules have the same internal representation in this interpreter, there is nothing more to do. *)\n| Module_unpack (_, expr) -> run_expression s ctx expr\n\nand run_structure s ctx _term_ =\n  let func nsf _term_ =\n    let%result res = nsf in\n    run_structure_item s res.ctx _term_ in\n  (* Fake result data used as first input of the fold function below *)\n  let fake_res = Unsafe.box { value = nil ; ctx = ctx } in\n  match _term_ with\n  | Structure (_, items) -> MLArray.fold func fake_res items\n\nlet run s ctx _term_ =\n  let%result res = run_structure s ctx _term_ in\n  Unsafe.box res.ctx\n'},
];
